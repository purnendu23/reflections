Q. What happens when you initialize a repository? Why do you need to do it?
A. When we initialize a repository using 'git init' a new file '.git' is created.
This is done so that git can track the changes we make to this repo from here on.


If you accidentally add a file to the staging area, you can remove it using git reset.
For example, if you accidentally add lesson_2_reflections.txt, but donâ€™t want it to be committed yet,
run git reset lesson_2_reflections.txt
and the file will be removed from the staging area, but it will still be in your working directory.

Q. How is the staging area different from the working directory and the repository? What value do you think it offers?
A. Staging Area - enables picking only a subset of the changes(files) which are relevant to the next commit.
So, all the files in the staging area are the ones where new feature has been implemented and can be part
of the same commit.


git diff ---> working_dir & staging_area
git diff --staged ---> staging_area & commit 1
git diff commit1 commit2 ---> commit1 & commit2

Q. How can you use the staging area to make sure you have one commit per logical change?
A. You add (to the staging area) only that subset of files which are relevant to the new feature/improvment/change.

Q. What are branches?
A. Branches are just labels for your commits.

Q. What are some situations when branches would be helpful in keeping your history organized? How would branches help?
A. If you want to implement a different version of the application in parallel, you should make a new branch.
Later, you will have the option of merging it with the original branch if you want to.

git log --graph --oneline master <br1> <br2> : "To view the graphical representation of the branches"

Q. How do the diagrams help you visualize the branch structure?
A. The diagrams are very helpful. They help you see all the branches which commits can be reached by each.
We can also see if there we are in a 'dangling' commit. If we are in such a dangling commit, we can
start a new branch there with the 'git checkout -b <new_branch_name>' and hence keep track of it.
